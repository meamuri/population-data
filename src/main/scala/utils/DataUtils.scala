package utils

import dao.{City, PartOfPeople}
import org.apache.spark.rdd.RDD
import org.apache.spark.sql.DataFrame

import scala.util.Try

/**
  * Модуль для работы с данными
  */
private object DataUtils {
  /**
    * Функция, позволяющая получить абстракцию абстракцию над данными,
    * предложенному для обработки в Spark: RDD
    * Такая коллекция будет содержать данные о городах,
    * причем будут отобраны только нужные данные о них,
    * и только актуальные для работы записи
    *
    * Функция предполагает, что all_data -- данные о населении обоих полов!
    * @param all_data набор данных в виде таблицы spark.sql.DataFrame,
    *                 из которой будут отобраны только нужные колонки,
    *                 и только актуальные строки
    * @param year год, который следует считать актуальным для данных.
    *             Так, если передан конкретный год, будет осуществлена попытка
    *             найти для каждого города данные именно за этот год.
    *             Если данные за этот год не найдены, будет браться
    *             самая свежая запись о городе из предложенных.
    *             Также существует специальное значение -1,
    *             означающая, что для каждого корода следует брать
    *             самую актуальную информацию
    * @return RDD набор из объектов case-класса "город"
    */
  def getCities(all_data: DataFrame, year: Int = -1): RDD[City] = {
    selectUsefulRows(selectUsefulData(all_data), year)
  }

  /**
    * Функция, позволяющая получить абстракцию абстракцию над данными,
    * предложенному для обработки в Spark: RDD
    * Такая коллекция будет содержать данные о городах,
    * причем будут отобраны только нужные данные о них,
    * и только актуальные для работы записи
    *
    * Функция предполагает, что all_data -- данные о населении разных полов!
    * @param all_data набор данных в виде таблицы spark.sql.DataFrame,
    *                 из которой будут отобраны только нужные колонки,
    *                 и только актуальные строки
    * @param year год, который следует считать актуальным для данных.
    *             Так, если передан конкретный год, будет осуществлена попытка
    *             найти для каждого города данные именно за этот год.
    *             Если данные за этот год не найдены, будет браться
    *             самая свежая запись о городе из предложенных.
    *             Также существует специальное значение -1,
    *             означающая, что для каждого корода следует брать
    *             самую актуальную информацию
    * @return RDD набор из объектов case-класса "город"
    */
  def getCitiesBothSexes(all_data: DataFrame, year: Int = -1): RDD[City] = {
    val cities = selectUsefulData(all_data)
    usefulRowsForBothSexes(cities, year)
  }

  /**
    * Функция отбирает нужную информацию из таблицы данных о населении городов
    * и представляет эту информацию в виде абстракции case class City
    * Все полученные строки объединяются в RDD набор для дальнейшей обработки
    * в Spark
    * @param all_data табличный набор данных, из которого требуется выбрать
    *                 только нужные столбцы и представить в виде экземпляра
    *                 case-класса city
    * @return RDD набор из объектов case-класса City
    *         Здесь еще присутствуют данные об одном городе, но за разные годы,
    *         поэтому требуется вызов функции, отбирающий только актуальные строки
    */
  private def selectUsefulData(all_data: DataFrame): RDD[City] = {
    all_data.select("Country or Area", "City", "Year", "Value", "Sex").rdd
      .map(row => {
        val country = Try(row(0).toString).getOrElse("null").replaceAll("\\.", "*")
        val city_name = Try(row(1).toString).getOrElse("null").replaceAll("\\.", "")
        val year = Try(row(2).toString.toInt).getOrElse(-1)
        val population = Try(row(3).toString.toDouble).getOrElse(0.0)
        val sex = PartOfPeople.strToChar(Try(row(4).toString).getOrElse("b"))
        City(country, city_name, year, population, sex)
      })
  }

  /**
    * Функция из перечня всех записей о городах
    * выбирает для каждого города только актуальную запись о мужском населении,
    * а также актуальную запись о женском населении города, а потом
    * объединяет их в одну коллекцию RDD
    * @param data Все все записи о городах в виде набора case-класс объектов
    * @param year год, который необходимо считать как актуальный
    *             Если указан -1, будут отбираться самые свежие записи
    *             Если за указанный год не найдена запись о городе,
    *             также будет отбираться самая свежая
    * @return возвращает список всех городов, где каждый город представлен двумя записями:
    *         одна хранит данные о мужском населении, другая -- о женском
    */
  private def usefulRowsForBothSexes(data: RDD[City], year: Int = -1): RDD[City] = {
    val tmp_m = selectUsefulRows(data.filter(city => city.sex == 'm'), year)
    val tmp_f = selectUsefulRows(data.filter(city => city.sex == 'f'), year)
    tmp_m.union(tmp_f)
  }

  /**
    * Функция из перечня всех записей о городах
    * выбирает для каждого города актуальную запись о количестве населения города
    * @param data Все все записи о городах в виде набора case-класс объектов
    * @param year год, который необходимо считать как актуальный
    *             Если указан -1, будут отбираться самые свежие записи
    *             Если за указанный год не найдена запись о городе,
    *             также будет отбираться самая свежая
    * @return возвращает список всех городов с актуальной информацией
    */
  private def selectUsefulRows(data: RDD[City], year: Int = -1): RDD[City] = {
    val tmp = data.map(city => (city.name, city.copy()))
      .groupByKey()
    val res = if (year == -1) {
      tmp.mapValues(cities => cities.maxBy(_.year))
    } else { // если нашли указанный год, берем за этот год, в противном случае самую свежую запись
      tmp.mapValues(cities => cities.find(city => city.year == year).getOrElse(cities.maxBy(_.year)))
    }
    res.map(pair => pair._2.copy())
  }

} // ... private Object DataUtils



